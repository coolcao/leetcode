# é¢˜ç›®
```
Given a non-negative index k where k â‰¤ 33, return the kth index row of the Pascal's triangle.

Note that the row index starts from 0.


In Pascal's triangle, each number is the sum of the two numbers directly above it.

Example:

Input: 3
Output: [1,3,3,1]
Follow up:

Could you optimize your algorithm to use only O(k) extra space?

```

# è§£æ
ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•° k<=33ï¼Œè¿”å›æ¨è¾‰ä¸‰è§’ä¸‹æ ‡ä¸ºkçš„è¡Œã€‚
æœ‰ä¸€ä¸ªé¢å¤–çš„é™åˆ¶ï¼Œä½¿ç”¨O(k)çš„é¢å¤–ç©ºé—´ã€‚
æ¨è¾‰ä¸‰è§’å¦‚å›¾ï¼š
![æ¨è¾‰ä¸‰è§’](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

æ­£å¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå»ç”Ÿæˆä¸€ä¸ªæ¨è¾‰ä¸‰è§’ï¼Œç„¶åè¿”å›ç¬¬kè¡Œå³å¯ï¼Œä½†æ˜¯é¢˜ç›®ä¸­æœ‰é™åˆ¶æ˜¯åªä½¿ç”¨O(k)çš„é¢å¤–ç©ºé—´ï¼Œè¿™å°±è¦æ±‚æˆ‘ä»¬ä¸å¯èƒ½ç”Ÿæˆä¸€ä¸ªå®Œæ•´çš„æ¨è¾‰ä¸‰è§’ï¼Œä»æ¨è¾‰ä¸‰è§’çš„ç»“æ„ä¸Šæˆ‘ä»¬çœ‹ï¼Œç¬¬kè¡Œè®°å½•æ˜¯ç”±ç¬¬k-1è¡Œè®°å½•ç”Ÿæˆçš„ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬åªéœ€è¦ä¿å­˜å‰ä¸€è¡Œä¾¿å¯ä»¥ç”Ÿæˆåä¸€è¡Œã€‚

# ä»£ç 
```golang
func getRow(rowIndex int) []int {
	pre := make([]int, rowIndex+1)
	pre[0], pre[rowIndex] = 1, 1
	if rowIndex == 0 {
		return pre
	}
	if rowIndex == 1 {
		pre[1] = 1
		return pre
	}
	pre[1] = 1
	current := make([]int, rowIndex+1)
	current[0], current[rowIndex] = 1, 1
	for row := 2; row <= rowIndex; row++ {
		for i := 1; i <= row; i++ {
			if i == row {
				current[i] = 1
			} else {
				current[i] = pre[i] + pre[i-1]
			}
		}
		pre, current = current, pre
		fmt.Printf("pre: %v\n", pre)
		fmt.Printf("current: %v\n", current)
	}
	return pre
}
```

æˆ‘ä»¬å…ˆåˆ›å»ºä¸¤ä¸ªå®šé•¿çš„slice preå’Œcurrentç”¨æ¥å­˜å‚¨å‰ä¸€ä¸ªæ•°ç»„å’Œå½“å‰æ•°ç»„ï¼Œç„¶åæ ¹æ®æ¨è¾‰ä¸‰è§’å®šä¹‰è¿›è¡Œè®¡ç®—ã€‚

è®¡ç®—å®Œä¸€è¡Œåï¼Œæˆ‘ä»¬æŠŠpreå’Œcurrentè¿›è¡Œäº¤æ¢ï¼Œç›¸å½“äºå›æ”¶currentç©ºé—´ï¼Œç„¶åå†åˆ©ç”¨ã€‚

golangä¸­sliceæ˜¯ä¸€ç§éå¸¸ç‰¹åˆ«çš„æ•°æ®ç»“æ„ï¼ŒåƒğŸ‘†ğŸ»æˆ‘ä»¬ä¸ºpre,currentå¼€è¾Ÿäº†ä¸¤å—å†…å­˜åŒºåŸŸï¼Œç„¶åæ¥å›åˆ‡æ¢ï¼Œè¿™æ ·ä»£ç å†™ç€æœ‰ç‚¹ç¹çï¼Œè¯•ç€æ”¹å˜ä¸€ä¸‹å†™æ³•ï¼š
```golang
func getRow(rowIndex int) []int {
	length := rowIndex + 1
	nums := make([]int, length*2)
	pre := nums[:length]

	pre[0], pre[rowIndex] = 1, 1
	if rowIndex == 0 || rowIndex == 1 {
		return pre
	}

	pre[1] = 1
	current := nums[length:]
	current[0], current[rowIndex] = 1, 1
	for row := 2; row <= rowIndex; row++ {
		for i := 1; i <= row; i++ {
			if i == row {
				current[i] = 1
			} else {
				current[i] = pre[i] + pre[i-1]
			}
		}
		pre, current = current, pre
	}
	return pre
}
```
ä¸Šé¢è¿™ç§å†™æ³•ï¼Œæˆ‘ä»¬å¼€è¾Ÿäº†ä¸€å—é•¿åº¦ä¸º2å€äºlengthçš„å†…å­˜åŒºåŸŸï¼Œç„¶åå°†pre, currentåˆ†åˆ«æŒ‡å‘å…¶å‰åŠéƒ¨åˆ†å’ŒååŠéƒ¨åˆ†ï¼Œåé¢æ‰€æœ‰çš„æ“ä½œéƒ½æ˜¯åœ¨è¿™å—å›ºå®šçš„å†…å­˜åŒºåŸŸä¸Šè¿›è¡Œï¼Œæ”¹å˜pre, currentä¹Ÿåªæ˜¯æ”¹å˜äº†ä¸€ä¸‹å…¶æŒ‡å‘å‰åŠæ®µè¿˜æ˜¯ååŠæ®µè€Œå·²ã€‚è¿™ç§å†™æ³•åªæ˜¯æ¢äº†ä¸€ä¸ªå†™æ³•ï¼Œå’ŒğŸ‘†ğŸ»ç¬¬ä¸€ç§æ–¹å¼åœ¨é€»è¾‘ä¸Šæ˜¯ä¸€æ¨¡ä¸€æ ·çš„ã€‚


