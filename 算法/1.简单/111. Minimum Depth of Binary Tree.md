# é¢˜ç›®
```
Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its minimum depth = 2.
```

# è§£æ
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼ŒæŸ¥æ‰¾å®ƒçš„æœ€å°æ·±åº¦ã€‚

æ ‘çš„æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹å¼€å§‹åˆ°æ‰€æœ‰å¶å­èŠ‚ç‚¹çš„æ‰€æœ‰è·¯å¾„ä¸­æœ€å°è·¯å¾„ã€‚

æˆ‘ä»¬å¯ä»¥éå†è¿™æ£µæ ‘ï¼Œå¦‚æœé‡åˆ°å¶å­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å°±åˆ¤æ–­å½“å‰å¶å­èŠ‚ç‚¹çš„è·¯å¾„æ˜¯å¦æ˜¯æœ€å°çš„ï¼Œå¦‚æœæ˜¯æœ€å°çš„ï¼Œå°±è¿”å›è¯¥æœ€å°å€¼å³å¯ã€‚

# ä»£ç å®ç°
## å…ˆåºéå†
```golang
func visit(root *TreeNode, level int, min *int) {
	if root.Left == nil && root.Right == nil {
		if *min > level {
			*min = level
		}
		return
	}
	if root.Left == nil {
		visit(root.Right, level+1, min)
		return
	}
	if root.Right == nil {
		visit(root.Left, level+1, min)
		return
	}

	visit(root.Left, level+1, min)
	visit(root.Right, level+1, min)

}

// éå†äºŒå‰æ ‘ï¼Œé‡åˆ°å¶å­èŠ‚ç‚¹ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹çš„è·¯å¾„æ˜¯å¦æœ€å°
func minDepth(root *TreeNode) int {
	if root == nil {
		return 0
	}
	min := math.MaxInt32
	visit(root, 1, &min)
	return min
}
```

è¿™é‡Œé¢å¤–å†™äº†ä¸€ä¸ªè®¿é—®æ–¹æ³•visit()ï¼Œä¸‰ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªæ˜¯è¦è®¿é—®çš„æ ‘èŠ‚ç‚¹ï¼Œç¬¬äºŒä¸ªæ˜¯è¯¥èŠ‚ç‚¹æ‰€å±çš„å±‚æ•°ï¼Œç¬¬ä¸‰ä¸ªæ˜¯ä¸€ä¸ªintç±»å‹çš„æŒ‡é’ˆï¼Œç”¨ä»¥è®°å½•æœ€å°è·¯å¾„ã€‚

å¦‚æœé‡åˆ°å¶å­èŠ‚ç‚¹ï¼ˆå·¦å³å­æ ‘å‡ä¸ºç©ºï¼‰ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹çš„å±‚çº§ï¼ˆä»£è¡¨æ­¤èŠ‚ç‚¹çš„è·¯å¾„ï¼‰å’Œå½“å‰è®°å½•çš„æœ€å°è·¯å¾„æ¯”è¾ƒï¼Œå¦‚æœæ¯”å½“å‰æœ€å°è·¯å¾„è¿˜å°ï¼Œåˆ™è¯¥è·¯å¾„è®°ä¸ºæœ€å°è·¯å¾„ã€‚å¦‚æœä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç»§ç»­è®¿é—®å…¶å­æ ‘ã€‚

åœ¨minDepth()å‡½æ•°ä¸­å®šä¹‰ä¸€ä¸ªæœ€å°å€¼ï¼Œä½¿ç”¨mathåº“é‡Œçš„ MaxInt32 ä½œä¸ºæœ€å°å€¼ã€‚ç„¶åå¼€å§‹è®¿é—®æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè®¿é—®å®Œå³å¯ã€‚

## å±‚æ¬¡éå†
ğŸ‘†ğŸ»ç¬¬ä¸€ä¸ªæ–¹å¼ï¼Œé‡‡ç”¨å…ˆåºéå†ï¼Œèƒ½è§£å†³é—®é¢˜ï¼Œä½†æ˜¯æ•ˆç‡ä¸æ€ä¹ˆå¥½ã€‚

å…·ä½“åŸå› æ˜¯ï¼Œé‡‡ç”¨å…ˆåºéå†ï¼Œä¸ç¡®å®šæœ€çŸ­è·¯å¾„åœ¨å·¦å­æ ‘è¿˜æ˜¯åœ¨å³å­æ ‘ï¼Œåªèƒ½ä»å·¦éå†åˆ°å³éå†å®Œæ•´æ£µæ ‘æ‰èƒ½ç¡®å®šæœ€çŸ­è·¯å¾„ã€‚

å…¶å®è¦æ±‚æœ€çŸ­è·¯å¾„ï¼Œå¯ä»¥é‡‡ç”¨å±‚æ¬¡éå†ã€‚å±‚æ¬¡éå†æ—¶ï¼Œé‡åˆ°ç¬¬ä¸€ä¸ªå¶å­èŠ‚ç‚¹ï¼Œå³æ˜¯è¯¥æ ‘çš„æœ€çŸ­è·¯å¾„ã€‚

```golang
type QueueNode struct {
	node  *TreeNode
	level int
}

// é‡‡ç”¨å±‚æ¬¡éå†ï¼Œå¦‚æœé‡åˆ°å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›è¯¥å¶å­èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ã€‚
func minDepth2(root *TreeNode) int {
	if root == nil {
		return 0
	}
	queue := []*QueueNode{&QueueNode{
		node:  root,
		level: 1,
	}}
	for len(queue) > 0 {
		current := queue[0]
		queue = queue[1:]
		if current.node.Left == nil && current.node.Right == nil {
			return current.level
		}
		if current.node.Right != nil {
			queue = append(queue, &QueueNode{
				level: current.level + 1,
				node:  current.node.Right,
			})
		}
		if current.node.Left != nil {
			queue = append(queue, &QueueNode{
				level: current.level + 1,
				node:  current.node.Left,
			})
		}
	}
	return 1
}
```

å±‚æ¬¡éå†éœ€è¦ä½¿ç”¨é˜Ÿåˆ—æ¥æš‚å­˜èŠ‚ç‚¹ï¼Œè¿™é‡Œè‡ªå®šä¹‰ä¸€ä¸ªé˜Ÿåˆ—èŠ‚ç‚¹ç»“æ„ QueueNode ï¼Œè®°å½•å½“å‰èŠ‚ç‚¹ä»¥åŠå½“å‰èŠ‚ç‚¹çš„å±‚æ¬¡ã€‚
ç„¶åå¼€å§‹å±‚æ¬¡éå†è¯¥äºŒå‰æ ‘ï¼Œé‡åˆ°ç¬¬ä¸€ä¸ªå¶å­èŠ‚ç‚¹ç›´æ¥è¿”å›è¯¥å¶å­èŠ‚ç‚¹çš„å±‚æ¬¡å³å¯ã€‚å› ä¸ºæˆ‘ä»¬é‡‡ç”¨çš„æ˜¯å±‚æ¬¡éå†ï¼Œæ­¤æ—¶çš„è·¯å¾„å¿…ç„¶ä¸ºæœ€çŸ­è·¯å¾„ã€‚